# this program is a version of the game pong. Two players control two paddles using Q & A for player one and
# P & L for player two. the goal is to bounce the ball against the opposing player's wall while preventing it
# from bouncing off of your wall; each time a bounce on the left or right wall is achieved, the corresponding
# player gains one point. The game ends when either player's score reaches 11, and that player wins

import pygame


def main():
    # initialize pygame -- this is required for rendering fonts
    pygame.init()

    # create the window and set its size to 500 width and 400 height
    size = (500, 400)
    screen = pygame.display.set_mode(size)

    # set the title of the window
    pygame.display.set_caption("Pong")

    # start the game
    game = Game(screen)
    game.play()


class Game:
    # the types of attributes that a game might have
    # --- general to all games
    # screen objects are being drawn to
    # background color
    # game clock
    # FPS limit
    # is the game over? (continue_game)
    # ---specific to pong:
    # ball
    # left paddle
    # right paddle
    # score limit

    # Game_screen is a pygame value containing information relating to the window the game will be played in
    def __init__(self, game_screen):

        # --- attributes that are general to all games
        self.screen = game_screen
        self.bg_color = pygame.Color("black")
        self.game_clock = pygame.time.Clock()
        self.FPS = 60
        self.continue_game = True
        self.close_clicked = False

        # --- attributes that are specific to pong
        self.score_limit = 11

        # game objects that are specific to pong

        # establish variables required for ball and create ball object
        ball_color = pygame.Color("white")
        ball_pos = [250, 200]
        ball_vel = [5, 5]
        ball_radius = 10
        self.ball = Ball(ball_color, ball_radius, ball_pos, ball_vel, self.screen)

        # establish variables applying to both paddles
        paddle_color = pygame.Color("white")
        paddle_dimensions = [10, 100]

        # establish variables for left paddle and create left paddle object
        left_paddle_pos = [50, 150]
        left_controls = (pygame.K_q, pygame.K_a)
        self.left_paddle = Paddle(paddle_color, paddle_dimensions, left_paddle_pos, self.screen, left_controls)
        self.left_scoreboard = self.left_paddle.scoreboard_render()

        # establish variables for right paddle and create right paddle object
        right_paddle_pos = [440, 150]
        right_controls = (pygame.K_p, pygame.K_l)
        self.right_paddle = Paddle(paddle_color, paddle_dimensions, right_paddle_pos, self.screen, right_controls)
        self.right_scoreboard = self.right_paddle.scoreboard_render()

    # This method is responsible for managing all events happening every frame
    def play(self):

        # Play the game until the player presses the close box.
        while not self.close_clicked:
            self.handle_events()
            self.draw()

            # look at game over conditions
            # if those conditions are not met:
            #   update the game state
            #   check if game over conditions are now met
            if self.continue_game:
                self.update()

                # check if player has won
                self.decide_continue()

            self.game_clock.tick(self.FPS)

    # this method is responsible for handling all user input into the game and routing to the correct method
    def handle_events(self):

        # Checks for new events generated by user input, and then change our
        # game state appropriately.
        for event in pygame.event.get():

            # check if player hit the "x" button on the window, and close the game if so
            if event.type == pygame.QUIT:
                self.close_clicked = True

            # route player control inputs to the correct paddle control method
            if event.type == pygame.KEYUP or event.type == pygame.KEYDOWN:
                if event.key in self.left_paddle.controls:
                    self.left_paddle.movement_controls(event)
                elif event.key in self.right_paddle.controls:
                    self.right_paddle.movement_controls(event)

    # this method is responsible for drawing all objects meant to be visible to the window
    def draw(self):
        # draws all game objects to screen

        # clear our screen before we draw game objects
        self.screen.fill(self.bg_color)

        # draw scoreboards to screen
        self.screen.blit(self.left_scoreboard, (0, 0))
        self.screen.blit(self.right_scoreboard, (self.screen.get_size()[0] - self.right_scoreboard.get_size()[0], 0))

        # draw our ball to screen
        self.ball.draw()

        # draw our paddles to screen
        self.left_paddle.draw()
        self.right_paddle.draw()

        # render all drawn objects to the screen
        pygame.display.flip()

    # this method is responsible for updating and monitoring the state of all objects in the window
    # this includes two paddles, one ball, two scoreboards and the interactions between them
    def update(self):

        # check for collisions
        self.collision_check()

        # update the scoreboards
        self.left_scoreboard = self.left_paddle.scoreboard_render()
        self.right_scoreboard = self.right_paddle.scoreboard_render()

        # Update all of our game's objects
        self.ball.move()
        self.left_paddle.move()
        self.right_paddle.move()

    # this method checks if either player has reached or surpassed the score limit set for the game
    # if so, it flags continue_game as False
    def decide_continue(self):
        # get the score of both paddles
        score_left = self.left_paddle.get_score()
        score_right = self.right_paddle.get_score()

        # check if score exceeds limit, if so, flag game to stop
        if score_left >= self.score_limit or score_right >= self.score_limit:
            self.continue_game = False

    # this method runs all the collision check methods
    def collision_check(self):
        self.ball_paddle_collision_check()
        self.ball_wall_collision_check()
        self.left_paddle.paddle_wall_collision_check()
        self.right_paddle.paddle_wall_collision_check()

    # this method checks for collisions between the ball and either of the paddles
    # if the ball is heading toward the wall owned by the paddle it is colliding with, it will bounce
    # if the ball is heading away from the wall owned by the paddle it is colliding with, it will pass through
    # this is to prevent the ball from becoming "stuck" between a paddle and the paddle's corresponding wall
    def ball_paddle_collision_check(self):

        # get the rectangle objects for the paddles
        left_rect = self.left_paddle.get_rect()
        right_rect = self.right_paddle.get_rect()

        # find the needed information about the ball
        ball_center = self.ball.get_coordinates()
        ball_radius = self.ball.get_radius()
        ball_velocity = self.ball.get_velocity()
        left_edge = ball_center[0] - ball_radius
        right_edge = ball_center[0] + ball_radius

        # Check if ball is going left and colliding with the left paddle
        if ball_velocity[0] < 0 and pygame.Rect.collidepoint(left_rect, left_edge, ball_center[1]):

            # if so, bounce on the x axis
            self.ball.bounce(0)

            # Check if ball is going left and colliding with the right paddle
        if ball_velocity[0] > 0 and pygame.Rect.collidepoint(right_rect, right_edge, ball_center[1]):

            # if so, bounce on the x axis
            self.ball.bounce(0)

    # this method checks for collisions between the ball and the borders of the game window
    # if found, the method will "bounce" the ball in the opposing direction
    # if the ball bounces off of the left or right wall, points are added to the opposite side's score
    def ball_wall_collision_check(self):

        # get information needed
        screen_dimensions = self.screen.get_size()  # list in [x, y] format
        ball_center = self.ball.get_coordinates()   # list in [x, y] format
        ball_radius = self.ball.get_radius()        # int
        ball_velocity = self.ball.get_velocity()    # list in [x, y] format

        # Check if ball is colliding with any of the screen borders
        for i in range(0, 2):  # i == 0 is checking in regards to X axis collisions, i == 1 in regards to Y axis.
            if ball_center[i] + ball_radius >= screen_dimensions[i] or ball_center[i] - ball_radius <= 0:

                # if ball collided with left wall, increment right player's score by one
                if i == 0 and ball_velocity[0] < 0:
                    self.right_paddle.score_increment()

                # if ball collided with right wall, increment left player's score by one
                if i == 0 and ball_velocity[0] > 0:
                    self.left_paddle.score_increment()

                # bounce ball on same axis as the one the collision took place on
                self.ball.bounce(i)


# this class represents a "ball" in pong
# a ball is a circle
# a ball bounces off of the edges of the window
# a ball bounces off of paddles when approaching their wall, but not when leaving
# when a ball bounces off of the left or right walls, the opposite side gains one point
class Ball:

    # ball_color is a pygame color value indicating the color of the ball
    # ball_radius is an integer determining the radius of the ball
    # ball_center is a list containing two integers representing the coordinates of the ball's center in [x, y] format
    # ball_velocity is a list containing the x and y velocity vectors of the ball as integers in [x, y] format
    # screen is a pygame screen value indicating which screen the ball will be printed to
    def __init__(self, ball_color, ball_radius, ball_center, ball_velocity, screen):
        self.color = ball_color
        self.radius = ball_radius
        self.center = ball_center
        self.velocity = ball_velocity
        self.screen = screen

    # axis is a integer containing either 0 or 1, correlating with the x axis and y axis respectively

    # this method inverts the velocity of the ball on the axis indicated in "axis", simulating a bounce with no friction
    def bounce(self, axis):
        self.velocity[axis] = self.velocity[axis] * -1

    # this method changes the location of the ball, simulating movement
    # this is done by adding the corresponding x and y velocity vectors to the ball's coordinates, found in self.center
    def move(self):
        for index in range(0, 2):
            self.center[index] = self.center[index] + self.velocity[index]

    # This method is responsible for drawing the ball at it's current position to the game window
    def draw(self):
        # Draw the ball onto the game's window
        pygame.draw.circle(self.screen, self.color, self.center, self.radius)

    # this method returns the coordinates of the center of the ball as a list in [x, y] format
    def get_coordinates(self):
        return self.center

    # this method returns the radius of the ball as an int
    def get_radius(self):
        return self.radius

    # this method returns the velocity of the ball
    def get_velocity(self):
        return self.velocity


# this class represents a 'paddle' in pong
# a paddle is a rectangle
# a paddle can vertically within the screen as directed by player inputs
# a paddle can bounce a ball coming towards it's wall, and ignore balls leaving it's wall
class Paddle:
    # paddle_color is a pygame color value indicating the colour of the paddle
    # paddle_dimensions is a list containing two integers for the width (index 0) and height (index 1) of the paddle
    # paddle_top_left is a list containing the starting coordinates of the paddle's top left corner in [x, y] format
    # screen is a pygame screen value indicating which screen the paddle will be printed to
    # movement_controls is a tuple containing the pygame values for the keys to move the paddle up and down in (up, down) format
    def __init__(self, paddle_color, paddle_dimensions, paddle_top_left, screen, controls):
        self.color = paddle_color
        self.velocity = [0, 0]
        self.screen = screen
        self.controls = controls
        self.up_control = controls[0]
        self.down_control = controls[1]
        self.score = 0
        self.rectangle = pygame.Rect(paddle_top_left[0], paddle_top_left[1], paddle_dimensions[0], paddle_dimensions[1])

    # this method offsets the paddle using "rect"'s inbuilt "move" function by passing in x and y velocity
    def move(self):
        self.rectangle = self.rectangle.move(self.velocity[0], self.velocity[1])

    # This method checks for any possible collisions between the walls and the paddle
    # If any are found, the paddle's velocity is set to 0, preventing it from leaving the window
    def paddle_wall_collision_check(self):

        # check if paddle is colliding with the roof or floor, If so, flag collision as True
        screen_dimensions = self.screen.get_size()
        if self.rectangle.top > 0 and self.velocity[1] < 0:
            collision = False
        elif self.rectangle.bottom < screen_dimensions[1] and self.velocity[1] > 0:
            collision = False
        else:
            collision = True

        # if paddle is colliding with anything, set it's vertical velocity to 0
        if collision:
            self.velocity[1] = 0

    # This method is responsible for drawing the paddle specified in it's call
    def draw(self):
        # Draw the paddle onto the game's window
        pygame.draw.rect(self.screen, self.color, self.rectangle)

    # event is a pygame "event" type variable containing information about player interaction with the game window

    # this method checks if the event passed into it is a keystroke (up or down) relating to the movement_controls for the
    # paddle specified in it's call. If so, it alters the paddle's vertical velocity accordingly
    def movement_controls(self, event):

        paddle_speed = 10  # pixels/frame (60 fps default)

        # if a key is released
        if event.type == pygame.KEYUP:
            # only reduce speed to 0 if the button released correlates to the current direction the paddle is moving in

            # if paddle is moving up and up key is released, set vertical velocity to 0
            if event.key == self.up_control and self.velocity[1] < 0:
                self.velocity[1] = 0

            # If paddle is moving down and down key is released, set vertical velocity to 0
            if event.key == self.down_control and self.velocity[1] > 0:
                self.velocity[1] = 0

        # if a key is pressed
        elif event.type == pygame.KEYDOWN:

            # if the key pressed is the assigned up key, set velocity to -1 * paddle_speed (up)
            if event.key == self.up_control:
                self.velocity[1] = -1 * paddle_speed

            # if the key pressed is the assigned up key, set velocity to paddle_speed (down)
            if event.key == self.down_control:
                self.velocity[1] = paddle_speed

    # this method renders a scoreboard consisting of the number of points the player indicated in "player" has earned
    # this scoreboard is returned as a surface that can be placed on the screen using the "blit" function later on
    def scoreboard_render(self):
        # Text settings
        font_size = 30
        font = pygame.font.SysFont("arial", font_size)
        color = pygame.Color("white")

        # render the scoreboard
        score = self.score
        score = str(score)
        scoreboard = pygame.font.Font.render(font, score, True, color)
        return scoreboard

    # this method increments one to the score of the paddle when called
    def score_increment(self):
        self.score += 1

    # this method returns the rectangle object for the paddle
    def get_rect(self):
        return self.rectangle

    # this method returns the score associated with the paddle when called
    def get_score(self):
        return self.score


main()
